=head1 The Sprog Scheduler

The L<Sprog::Machine> class implements a simple scheduler based around the Gtk
event loop.

Each gear in a machine has an input message queue.  One or more gears can
register themselves as data providers - which means they will place messages
in the queue of the next downstream gear as data becomes available.

As long as the scheduler is running, each gear is given a chance to process
messages from its queue.  If a data provider is exhausted (for example when it
reaches the end of file), it unregisters itself.  When a machine has no queued
messages and no registered data providers, its job is done and the machine
stops.

=head2 Initialisation

Before a machine starts 'running', the C<prime()> method is called on each gear
in turn.  Gears can do whatever initialisation they need in this method.
Typically at least the first gear in the machine would use this opportunity to
register itself as a data provider.

The machine would then call each data provider's C<send_data()> method.  A
provider may immediately use its C<msg_out()> method to place a message in the
input queue of the next downstream gear.  In real life, it's more likely that a
provider would set up a Gtk IO event handler to wait for data on a filehandle
and call C<msg_out()> from this handler when the IO event occurs.

=head2 Message Processing

The scheduler arranges for each gear to process messages from its queue.  A
message is synonymous with a method call, so for example if a gear has a 'data'
message in its queue, the scheduler will arrange for the gear's C<data()>
method to be called.

The scheduler's message processing loop is called from a Gtk idle handler, to
ensure that the user interface (particularly the 'stop' button) remains
responsive while the machine is running.

The scheduler gives priority to gears at the end (bottom) of the machine.

When there are no messages in the queues of any gears, the scheduler 'stalls'
the machine (so it's not waiting in a busy loop) and calls each data provider's
C<send_data()> method.  If a data provider provides data, the machine is
unstalled.  If a data provider is exhausted it unregisters itself.

When there are no registered data providers and all messages have been
processed, the machine stops - job done.
